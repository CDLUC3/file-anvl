.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::ANVL 3"
.TH File::ANVL 3 "2009-08-25" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
File::ANVL \- routines to support A Name Value Language
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use File::ANVL;        # to import routines into a Perl script
.Ve
.PP
.Vb 3
\& $elem = anvl_fmt(      # format ANVL element, wrapping to 72 cols;
\&         $label,        # $label to appear to left of colon (:)
\&         $string );     # $string to appear to right of colon
.Ve
.PP
.Vb 4
\& anvl_recsplit(         # split record into array of name-value pairs;
\&         $record,       # input record; arg 2 is reference to returned
\&         $r_elems,      # array; optional arg 3 (default 0) requires
\&         $strict );     # properly indented continuation lines
.Ve
.PP
.Vb 3
\& anvl_valsplit(         # split ANVL value into an array of subvalues
\&         $value,        # input value; arg 2 is reference to returned
\&         $r_svals );    # array of arrays of returned values
.Ve
.PP
.Vb 4
\& anvl_rechash(          # split ANVL record into hash of elements
\&         $record,       # input record; arg 2 is reference to returned
\&         $r_hash,       # hash; a value is scalar, or array of scalars
\&         $strict );     # if more than one element shares its name
.Ve
.PP
.Vb 1
\& anvl_decode( $str );   # ANVL-decode string
.Ve
.PP
.Vb 1
\& anvl_encode( $str );   # ANVL-encode string
.Ve
.PP
.Vb 2
\& anvl_name_naturalize(  # convert name from sort-friendly to natural
\&         $name );       # word order using ANVL inversion points
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is brief documentation for the \fB\s-1ANVL\s0\fR Perl module, with
support for representing data or metadata values in the \s-1ANVL\s0 format.
\&\s-1ANVL\s0 (A Name Value Language) is label-colon-value format similar
to email headers.
.PP
The \f(CW\*(C`anvl_fmt()\*(C'\fR function returns a plain text string wrapped to 72
colums in label-colon-value format) representing an anvl element.  It
trims whitspace but preserves internal newlines.  In an upcoming release
it will ANVL-encode characters that would otherwise prevent correct
parsing.  Here's an example of how to create an \s-1ERC\s0 with Dublin Kernel
metadata.
.PP
.Vb 6
\&     $anvl_record = anvl_fmt("erc")
\&         . anvl_fmt("who", $creator)
\&         . anvl_fmt("what", $title)
\&         . anvl_fmt("when", $date)
\&         . anvl_fmt("where", $identifier)
\&         . "\en";    # 2nd newline in a row terminates ANVL record
.Ve
.PP
The \f(CW\*(C`anvl_recsplit()\*(C'\fR function splits an \s-1ANVL\s0 record into elements,
returning them via the array reference given as the second argument.  Each
returned element is a pair of elements: a name and a value.  An optional
third argument, if true (default 0), rejects unindented continuation
lines, a common formatting mistake.  This function returns the empty
string on success, or message beginning \*(L"warning: ...\*(R" or \*(L"error: ...\*(R".
Here's an example that extracts and uses the first returned element.
.PP
.Vb 5
\&     ($msg = anvl_recsplit($record, $elemsref)
\&         and die "anvl_recsplit: $msg";  # report what went wrong
\&     print scalar($$elemsref), " elements found\en"
\&         "First element label is $$elemsref[0]\en",
\&         "First element value is $$elemsref[1]\en";
.Ve
.PP
The \f(CW\*(C`anvl_valsplitter()\*(C'\fR function splits an \s-1ANVL\s0 value into sub-values 
(svals) and repeated values (rvals), returning them as an array of arrays
via the array reference given as the second argument.  The top-level of
the array represents svals and the next level represents rvals.  This
function returns the empty string on success, or message beginning
\&\*(L"warning: ...\*(R" or \*(L"error: ...\*(R".
.PP
The \f(CW\*(C`anvl_rechash()\*(C'\fR function splits an \s-1ANVL\s0 record into elements,
returning them via the hash reference given as the second argument.  A
hash key is defined for each element name found.  Under that key is
stored the corresponding element value, or an array of values if more
than one occurrence of the element name was encountered.  This function
returns the empty string on success, or message beginning \*(L"warning: ...\*(R"
or \*(L"error: ...\*(R".
.PP
The \f(CW\*(C`anvl_decode()\*(C'\fR function takes an ANVL-encoded string and returns it 
after converting encoded characters to the standard representaion (e.g.,
\&\f(CW%vb\fR becomes `|').  The \f(CW\*(C`anvl_encode()\*(C'\fR function does the opposite.
.PP
The \f(CW\*(C`anvl_name_naturalize()\*(C'\fR function takes an \s-1ANVL\s0 string (aval)
and returns it after inversion at any designated inversion points.
The input string will be returned if it does not end in a comma (`,').
For example,
.PP
.Vb 1
\&     anvl_name_naturalize("Smith, Pat,");
.Ve
.PP
returns \*(L"Pat Smith\*(R".
.SH "SEE ALSO"
.IX Header "SEE ALSO"
A Name Value Language (\s-1ANVL\s0)
	<http://www.cdlib.org/inside/diglib/ark/anvlspec.pdf>
.PP
A Metadata Kernel for Electronic Permanence (\s-1PDF\s0)
	<http://journals.tdl.org/jodi/article/view/43>
.SH "HISTORY"
.IX Header "HISTORY"
This is an alpha version of \s-1ANVL\s0 tools.  It is written in Perl.
.SH "AUTHOR"
.IX Header "AUTHOR"
John A. Kunze \fIjak at ucop dot edu\fR
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2009 \s-1UC\s0 Regents.  Open source Apache License, Version 2.
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
Perl Modules: Text::Wrap
.PP
Script Categories:
.PP
\&\s-1UNIX\s0 : System_administration
