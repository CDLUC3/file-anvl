.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::ANVL 3pm"
.TH File::ANVL 3pm "2010-03-15" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::ANVL \- routines to support A Name Value Language
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use File::ANVL;       # to import routines into a Perl script
\&
\& getlines(             # read from $filehandle (defaults to *ARGV) up to
\&         $filehandle   # blank line; returns record read or undef on EOF;
\&         );            # record may be all whitespace (almost EOF)
\&
\& trimlines(            # strip initial whitespace from record, often just
\&         $record,      # returned by getlines(), and return remainder;
\&         $r_wslines,   # optional ref to line count in trimmed whitespace
\&         $r_rrlines ); # optional ref to line count of real record lines
\&
\& anvl_recarray(        # split $record into array of lineno\-name\-value
\&         $record,      # triples, first triple being <anvl, beta, "">
\&         $r_elems,     # reference to returned array
\&         $lineno,     # starting line number (default 1)
\&         $opts );      # options/default, eg, comments/0, autoindent/1
\&
\& erc_anvl_expand_array(# change short ERC ANVL array to long form ERC
\&         $r_elems );   # reference to array to modify in place
\&
\& anvl_valsplit(        # split ANVL value into an array of subvalues
\&         $value,       # input value; arg 2 is reference to returned
\&         $r_svals );   # array of arrays of returned values
\&
\& anvl_rechash(         # split ANVL record into hash of elements
\&         $record,      # input record; arg 2 is reference to returned
\&         $r_hash,      # hash; a value is scalar, or array of scalars
\&         $strict );    # if more than one element shares its name
\&
\& anvl_decode( $str );     # decode ANVL\-style %xy chars in string
\&
\& anvl_name_naturalize(   # convert name from sort\-friendly to natural
\&         $name );        # word order using ANVL inversion points
\&
\& anvl_om(                # read and process records from *ARGV
\&         $om,            # a File::OM formatting object
\&   {                     # a hash reference to various options
\&   autoindent => 0,      # don\*(Aqt (default do) correct sloppy indention
\&   comments => 1,        # do (default don\*(Aqt) preserve input comments
\&   verbose => 1,         # output record and line numbers (default don\*(Aqt)
\&   ... } );              # other options listed later
\&
\& anvl_opt_defaults();    # return hash reference with factory defaults
\&
\& *DEPRECATED*
\& anvl_recsplit(         # split record into array of name\-value pairs;
\&         $record,       # input record; arg 2 is reference to returned
\&         $r_elems,      # array; optional arg 3 (default 0) requires
\&         $strict );     # properly indented continuation lines
\& anvl_encode( $str );   # ANVL\-encode string
\&
\& *REPLACED*
\& # instead of anvl_fmt use File::OM::ANVL object\*(Aqs \*(Aqelems\*(Aq method
\& $elem = anvl_fmt(     # format ANVL element, wrapping to 72 columns
\&         $name,        # $name is what goes to left of colon (:)
\&         $value,       # $value is what goes to right of colon
\&         ... );        # more name/value pairs may follow
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is documentation for the \fB\s-1ANVL\s0\fR Perl module, which provides a
general framework for data represented in the \s-1ANVL\s0 format.  \s-1ANVL\s0 (A Name
Value Language) represents elements in a label-colon-value format similar
to email headers.  Specific conversions, based on an \*(L"output multiplexer\*(R"
File::OM, are possible to \s-1XML\s0, Turtle, \s-1JSON\s0, and Plain unlabeled text.
.PP
The \fB\s-1OM\s0\fR package can also be used to build records from scratch in \s-1ANVL\s0
or other the formats.  Below is an example of how to create a particular
kind of \s-1ANVL\s0 record known as an \s-1ERC\s0 (which uses Dublin Kernel metadata).
For the formats \s-1ANVL\s0, Plain, and \s-1XML\s0, the returned text string by default
is wrapped to 72 columns.
.PP
.Vb 9
\&     use File::OM;
\&     my $om = File::OM\->new("ANVL");
\&     $anvl_record = $om\->elems(
\&         "erc", "",
\&         "who", $creator,
\&         "what", $title,
\&         "when", $date,
\&         "where", $identifier)
\&         . "\en";    # 2nd newline in a row terminates ANVL record
.Ve
.PP
The \f(CW\*(C`getlines()\*(C'\fR function reads from \f(CW$filehandle\fR up to a blank line and
returns the lines read.  This is a general function for reading
\&\*(L"paragraphs\*(R", which is useful for reading \s-1ANVL\s0 records.  If unspecified,
\&\f(CW$filehandle\fR defaults to *ARGV, which makes it easy to take input from
successive file arguments specified on the command line (or from \s-1STDIN\s0 if
none) of the calling program.
.PP
For convenience, \f(CW\*(C`trimlines()\*(C'\fR is often used to process the record just
returned by \f(CW\*(C`getlines()\*(C'\fR.  It strips leading whitespace, optionally
counts lines, and returns undef if the passed record is undefined or
contains only whitespace, both being equivalent to end-of-file (\s-1EOF\s0).
.PP
These functions treat whitespace specially.  Input is read up until at
least one non-whitespace character and a blank line (two newlines in a
row) or \s-1EOF\s0 is reached.  If \s-1EOF\s0 is reached and the record would contain
only whitespace, undef is returned.  Input line counts for preliminary
trimmed whitespace ($wslines) and real record lines ($rrlines) can be
returned through optional scalar references given to \f(CW\*(C`trimlines()\*(C'\fR.
These functions work together to permit the caller access to all inputs,
to accurate line counts, and a familiar \*(L"loop until \s-1EOF\s0\*(R" paradigm, as in
.PP
.Vb 1
\&     while (defined trimlines(getlines(), \e$wslcount, \e$rrlcount)) ...
.Ve
.PP
The \f(CW\*(C`anvl_recarray()\*(C'\fR function splits an \s-1ANVL\s0 record into elements,
returning them via the array reference given as the second argument. Each
returned element is a triple consisting of line number, name, and value.
An optional third argument gives the starting line number (default 1).
An optional fourth argument is a reference to a hash containing options;
the argument { comments => 1, autoindent => 0 } will cause comments to be
kept (stripped by default) and recoverable indention errors to be flagged
as errors (corrected to continuation lines by default).  This function
returns the empty string on success, or a message beginning \*(L"warning:
\&...\*(R" or \*(L"error: ...\*(R".
.PP
The first triple of the returned array is special in that it describes
the origin of the record; its elements are
.PP
.Vb 4
\&     INDEX   NAME        VALUE
\&       0     format      original format ("ANVL", "JSON", "XML", etc)
\&       1     <unused>
\&       2     <unused>
.Ve
.PP
The remaining triples are free form except that the values will have been
drawn from the original format and possibly decoded.  The first item
(\*(L"lineno\*(R") in each remaining triple is a number followed by a letter,
such as \*(L"34:\*(R" or \*(L"6#\*(R".  The number indicates the line number (or octet
offset, depending on the origin format) of the start of the element.  The
letter is either ':' to indicate a real element or '#' to indicate a
comment; if the latter, the element name has no defined meaning and the
comment is contatined in the value.  Here's example code that reads a
3\-element record and reformats it.
.PP
.Vb 9
\&     ($msg = File::ANVL::anvl_recarray(\*(Aq
\&     a: b c
\&     d:  e
\&       f
\&     g:
\&       h i
\&     \*(Aq     and die "anvl_recarray: $msg";  # report what went wrong
\&     for ($i = 4; $i < $#elems; $i += 3)
\&         { print "[$elems[$i] <\- $elems[$i+1]]  "; }
.Ve
.PP
which prints
.PP
.Vb 1
\&     [a <\- b c]  [d <\- e f]  [g <\- h i]
.Ve
.PP
\&\f(CW\*(C`erc_anvl_expand_array()\*(C'\fR inspects and possibly modifies in place the
kind of element array resulting from a call to \f(CW\*(C`anvl_recarray()\*(C'\fR.  It
returns the empty string on success, otherwise an error message.  This
routine is useful for transforming a short form \s-1ERC\s0 \s-1ANVL\s0 record into long
form, for example, expanding \f(CW\*(C`erc: a | b | c | d\*(C'\fR into the equivalent,
.PP
.Vb 5
\&     erc:
\&     who: a
\&     what: b
\&     when: c
\&     where: d
.Ve
.PP
The \f(CW\*(C`anvl_valsplit()\*(C'\fR function splits an \s-1ANVL\s0 value into sub-values 
(svals) and repeated values (rvals), returning them as an array of arrays
via the array reference given as the second argument.  The top-level of
the array represents svals and the next level represents rvals.  This
function returns the empty string on success, or a message beginning
\&\*(L"warning: ...\*(R" or \*(L"error: ...\*(R".
.PP
The \f(CW\*(C`anvl_rechash()\*(C'\fR function splits an \s-1ANVL\s0 record into elements,
returning them via the hash reference given as the second argument.  A
hash key is defined for each element name found.  Under that key is
stored the corresponding element value, or an array of values if more
than one occurrence of the element name was encountered.  This function
returns the empty string on success, or a message beginning \*(L"warning: ...\*(R"
or \*(L"error: ...\*(R".
.PP
The \f(CW\*(C`anvl_decode()\*(C'\fR function takes an ANVL-encoded string and returns it
after converting encoded characters to the standard representaion (e.g.,
\&\f(CW%vb\fR becomes `|').  Some decoding, such as for the expansion block below,
.PP
.Vb 7
\&     print anvl_decode(\*(Aqhttp://example.org/node%{
\&                 ? db = foo
\&                 & start = 1
\&                 & end = 5
\&                 & buf = 2
\&                 & query = foo + bar + zaf
\&            %}\*(Aq);
.Ve
.PP
will affect an entire region.  This code prints
.PP
.Vb 1
\&  http://example.org/node?db=foo&start=1&end=5&buf=2&query=foo+bar+zaf
.Ve
.PP
The \f(CW\*(C`anvl_name_naturalize()\*(C'\fR function takes an \s-1ANVL\s0 string (aval)
and returns it after inversion at any designated inversion points.
The input string will be returned if it does not end in a comma (`,').
For example, \*(L"Pat Smith\*(R" is returned by the call,
.PP
.Vb 1
\&     anvl_name_naturalize("Smith, Pat,");
.Ve
.PP
The \f(CW\*(C`anvl_om()\*(C'\fR routine takes a formatting object created by a call to
\&\f(CW\*(C`File::OM($format)\*(C'\fR, reads a stream of \s-1ANVL\s0 records, processes each
element, and calls format-specific methods to build the output.  Those
methods are typically affected by transferring command line options in at
object creation time.
.PP
.Vb 6
\&     use File::ANVL;
\&     use File::OM;
\&     my $fmt = $opt{format};       
\&     $om = File::OM\->new($opt{format},      # from command line
\&         {comments => $opt{comments}) or    # from command line
\&             die "unknown format $fmt";
.Ve
.PP
Options control various aspects of reading \s-1ANVL\s0 input records.  The
\&'autoindent' option (default on) causes the parser to recover if it can
when continuation lines are not properly indented.  The 'comments'
options (default off) causes input comments to be preserved in the
output, format permitting.  The 'verbose' option inserts record and line
numbers in comments.  Pseudo-comments will be created for formats that
don't natively define comments (\s-1JSON\s0, Plain).
.PP
Like the individual \s-1OM\s0 methods, \f(CW\*(C`anvl_om()\*(C'\fR returns the built string by
default, or the return status of \f(CW\*(C`print\*(C'\fR using the file handle supplied
as the 'outhandle' options (normally set to '') at object creation time,
for example,
.PP
.Vb 1
\&     { outhandle => *STDOUT }
.Ve
.PP
The way \f(CW\*(C`anvl_om()\*(C'\fR works is roughly as follows.
.PP
.Vb 10
\&     $om\->ostream();                                    # open stream
\&     ... { # loop over all records, eg, $recnum++
\&     $anvlrec = trimlines(getlines());
\&     last         unless $anvlrec;
\&     $err = anvl_recarray($anvlrec, $$o{elemsref}, $startline, $opts);
\&     $err         and return "anvl_recarray: $err";
\&     ...
\&     $om\->orec($anvlrec, $recnum, $startline);          # open record
\&     ...... { # loop over all elements, eg, $elemnum++
\&     $om\->elem($name, $value, $elemnum, $lineno);       # do element
\&     ...... }
\&     $om\->crec($recnum);                                # close record
\&     ... }
\&     $om\->cstream();                                    # close stream
.Ve
.PP
\&\s-1DEPRECATED:\s0 The \f(CW\*(C`anvl_recsplit()\*(C'\fR function splits an \s-1ANVL\s0 record into
elements, returning them via the array reference given as the second
argument.  Each returned element is a pair of elements: a name and a
value.  An optional third argument, if true (default 0), rejects
unindented continuation lines, a common formatting mistake.  This
function returns the empty string on success, or message beginning
\&\*(L"warning: ...\*(R" or \*(L"error: ...\*(R".  Here's an example that extracts and uses
the first returned element.
.PP
.Vb 5
\&     ($msg = anvl_recsplit($record, $elemsref)
\&         and die "anvl_recsplit: $msg";  # report what went wrong
\&     print scalar($$elemsref), " elements found\en",
\&         "First element label is $$elemsref[0]\en",
\&         "First element value is $$elemsref[1]\en";
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
A Name Value Language (\s-1ANVL\s0)
	<http://www.cdlib.org/inside/diglib/ark/anvlspec.pdf>
.PP
A Metadata Kernel for Electronic Permanence (\s-1PDF\s0)
	<http://journals.tdl.org/jodi/article/view/43>
.SH "HISTORY"
.IX Header "HISTORY"
This is a beta version of \s-1ANVL\s0 tools.  It is written in Perl.
.SH "AUTHOR"
.IX Header "AUTHOR"
John A. Kunze \fIjak at ucop dot edu\fR
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2009\-2010 \s-1UC\s0 Regents.  Open source \s-1BSD\s0 license.
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
Perl Modules: File::OM
.PP
Script Categories:
.PP
\&\s-1UNIX\s0 : System_administration
